#!/usr/bin/env zsh

# For screenfetches on anonymous imageboards
anon() {
    local name="anonymous"
    local host="gentoo"

    PS1=${PS1//\%n/"$name"} PS1=${PS1//\%M/"$host"}
    printf '\033c'
}

# For comparing binary files
bdiff() {
    if [[ $# -lt 2 ]]; then
        echo >&2 'Not enough arguments.'
        echo >&2 'Usage: bdiff first-file second-file'
        return 1
    fi

    cmp -l "$1" "$2" | gawk '{printf "%08X %02X %02X\n", $1-1, strtonum(0$2), strtonum(0$3)}'
}

# Currency conversion. Be sure to use official abbreviations
cconv() {
    wget -qO- "http://www.google.com/finance/converter?a=$1&from=$2&to=$3" | sed '/res/!d;s/<[^>]*>//g';
} 

# cd function similar to the one provided with bash
#cd() {
#
#}

# A command replacement that says 'this command is disabled'.
command-disabled() {
    echo >&2 'This command has been disabled for safety purposes.'
    echo >&2 'If you really want to run it, invoke it directly. (e.g. /bin/false instead of false)'
    return 1
}

# A simple confirmation message. Usage: 'confirm && (action)'
confirm() {
    read -p "Are you sure? [y/N] " confirm
    case "$confirm" in
        yes) return 0 ;;
        y) return 0 ;;
        Y) return 0 ;;
        *) return 1 ;;
    esac
}

# Simple function to calculate date differences
datediff() {
    d1=$(date -d "$1" +%s)
    d2=$(date -d "$2" +%s)
    echo $(( (d1 - d2) / 86400 )) days
}

# Easily convert from base64
decode64() {
    if [[ $# -eq 0 ]]; then
        cat | base64 --decode
    else
        echo "$1" | base64 --decode
    fi
}

# Easily convert to base64
encode64() {
    if [[ $# -eq 0 ]]; then
        cat | base64
    else
        echo "$1" | base64
    fi
}

# Batch converts from one format to another
ffbatch() {
    if [[ $# -lt 2 ]]; then
        echo >&2 'Not enough arguments.'
        echo >&2 'Usage: ffbatch mp3 ogg'
    fi

    find -type f -name "*.$1" -print0 \
        | while read -d $'\0' a; do
            ffmpeg -i "$a" "${a[@]/%$1/$2}" < /dev/null
        done
    #rm -ir **/*.$1
}

# Joins L and R tracks into a single file.
ffstereo() {
    if [[ $# -lt 3 ]]; then
        echo >&2 'Not enough arguments.'
        echo >&2 'Usage: ffstereo left-track-file right-track-file output-file'
        return 1
    fi

    ffmpeg -i "$1" -i "$2" -filter_complex "[0:a][1:a]amerge=inputs=2[aout]" -map "[aout]" -c:a flac "$3"
}

# Changes the volume of a video or audio file.
ffvolume() {
    if [[ $# -lt 3 ]]; then
        echo >&2 'Not enough arguments.'
        echo >&2 'Usage: ffvolume input-file output-file volume-modifier'
        return 1
    fi

    ffmpeg -i "$1" -af "volume=$3" "$2"
}

# Look for a certain .desktop file
findapp() {
    for arg in "$@"; do
        grep -rnw "$arg" /usr/share/applications/
        grep -rnw "$arg" ~/.local/share/applications/
    done
}

# Insult the user if their command fails.
insult() {
    # Warning: slow
    printf 'root says: '
    curl -s randominsults.net | sed -n '/<strong>/{s;^.*<i>\(.*\)</i>.*$;\1;p}'
}

# List dbus services
lsdbus() {
    if [[ $# -eq 0 ]] || [[ $1 == '--help' ]]; then
        echo >&2 'Not enough arguments.'
        echo >&2 'Usage: lsdbus (session | system)'
        return 1
    fi

    dbus-send "--$1" \
              --dest=org.freedesktop.DBus \
              --type=method_call \
              --print-reply \
              /org/freedesktop \
              org.freedesktop.DBus.ListNames
}

# List osu! songs
lsosu() {
    if [[ $# -eq 0 ]]; then
        ls /opt/osu/game/Songs
    else
        ls /opt/osu/game/Songs | grep -i "$1"
    fi
}

# Print your most used shell commands
mostused() {
    history \
      | awk 'BEGIN {FS="[ \t]+|\\|"} {print $3}' \
      | sort \
      | uniq -c \
      | sort -nr \
      | head
}

# Pretty print a JSON file
pjson() {
    echo "$@" | python -m json.tool
}

# Generate a dice roll
roll() {
    if [[ $# -gt 1 ]]; then
        case "$1" in
            d*) local upper="${1:1:-1}" ;;
            D*) local upper="${1:1:-1}" ;;
            *) local upper="$1" ;;
        esac
    else
        local upper=100
    fi

    echo $[ 1 + $[ RANDOM % "$upper" ] ]
}

# Run one of my scripts without specifying the path
scr() {
    if [[ $# -eq 0 ]]; then
        printf >&2 'Usage: scr script-name.\n'
        return 1
    fi

    IFS=$'\n' \
    local scripts=($(find -L '/usr/local/scripts' -iname "*$1*" -executable -print))
    local scriptcount="${#scripts[@]}"

    if [[ $scriptcount -eq 0 ]]; then
        printf >&2 'Cannot find script "%s".\n' "$1"
        return 1
    elif [[ $scriptcount -gt 1 ]]; then
        printf >&2 'Multiple script candidates:\n'
        printf >&2 '%s\n' "${scripts[@]}"
        return 1
    else
        local script="${scripts[1]}"
        echo "$script"
        shift
        "$script" "$@"
        return 0
    fi
}

# Set the title of the terminal
settitle() {
   echo -ne "\e]2;$@\a\e]1;$@\a"
}

# Changes up how the sl train looks
sl() {
    local sett=e
    local rand=$RANDOM

    [[ $[ $rand & 1 ] -gt 0 ]] && sett+=a
    [[ $[ $rand & 2 ] -gt 0 ]] && sett+=l
    [[ $[ $rand & 4 ] -gt 0 ]] && sett+=F
    [[ $[ $rand & 8 ] -gt 0 ]] && sett+=c
    
    env sl "-$sett"
}

# Ask for confirmation and then suspend
suspend() {
    confirm && \
    suspendnow
}

# Suspend the computer
suspendnow() {
    systemctl suspend
}

# Suspend and lock the screen
suspendlock() {
    confirm && {
        suspendnow
        scr i3_lock.sh
    }
}

# Suspend and lock the tty
suspendvlock() {
    confirm && {
        suspendnow
        vlock
    }
}

# List the options supported by this terminal.
termsupport() {
    infocmp -1 | \
      sed -nu 's/^[ \000\t]*//;s/[ \000\t]*$//;/[^ \t\000]\{1,\}/!d;/acsc/d;s/=.*,//p' | \
      column -c80
}

# Make a total of all the integer items in a column
totalcol() {
    if [[ -z $1 ]]; then
        return 1
    fi

    awk "{total += \$$1} END {print total}"
}

# Play some random white noise
whitenoise() {
    play -n synth 60:00 brownnoise -65 tremolo .20 vol -20db
}

